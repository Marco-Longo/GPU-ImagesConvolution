#pragma OPENCL EXTENSION cl_khr_fp64 : enable
typedef float  real;
typedef float2 complex;
typedef float4 complex2;
typedef float8 complex4;

constant sampler_t sampler =
    CLK_NORMALIZED_COORDS_FALSE |
    CLK_ADDRESS_NONE |
    CLK_FILTER_NEAREST;

#define _2PI 6.283185307179586476925f

kernel void kerinit(global real* restrict out, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    if (c >= ncols || r >= nrows)
        return;

    if(r == 1 && c == 1)
        out[r*ncols+c] = 1.0;
    else
        out[r*ncols+c] = 0.0;
}

kernel void fft_mat(global real* restrict src, global complex* restrict dest,
                    int nrows, int ncols)
{
#if 0
    const int v = get_global_id(0);
    const int u = get_global_id(1);
#else
    const int u = get_global_id(0);
    const int v = get_global_id(1);
#endif

    if(v >= ncols || u >= nrows)
        return;

    complex acc = (complex)(0, 0);
    const real row_coeff = u/(real)nrows;
    const real col_coeff = v/(real)ncols;

    for(int row=0; row<nrows; ++row)
        for(int col=0; col<ncols; ++col)
        {
            real val = src[row*ncols+col];
            real r = _2PI * ((row*row_coeff) + (col*col_coeff));
            acc += (complex)(val*cos(r), -sin(r)*val);
        }

    dest[u*ncols+v] = (complex)(acc.x, acc.y);
}

kernel void fft_img(image2d_t read_only src, global complex* restrict dest)
{
#if 0
    const int v = get_global_id(0);
    const int u = get_global_id(1);
#else
    const int u = get_global_id(0);
    const int v = get_global_id(1);
#endif
    const int ncols = get_image_width(src);
    const int nrows = get_image_height(src);

    if(v >= ncols || u >= nrows)
        return;

    complex acc = (complex)(0, 0);
    const real row_coeff = u/(real)nrows;
    const real col_coeff = v/(real)ncols;

    for(int row=0; row<nrows; ++row)
        for(int col=0; col<ncols; ++col)
        {
            int4 val = read_imagei(src, sampler, (int2)(row, col)); //f(x,y)
            real r = _2PI * ((row*row_coeff) + (col*col_coeff));
            acc += (complex)(val.x*cos(r), -sin(r)*val.x); //?
        }

    dest[u*ncols+v] = (complex)(acc.x, acc.y);
}

kernel void ifft(global complex* restrict src, image2d_t write_only dest)
{
#if 0
    const int v = get_global_id(0);
    const int u = get_global_id(1);
#else
    const int u = get_global_id(0);
    const int v = get_global_id(1);
#endif
    const int ncols = get_image_width(dest);
    const int nrows = get_image_height(dest);
    if(v >= ncols || u >= nrows)
        return;

    real acc = 0.0;
    const real row_coeff = u/(real)nrows;
    const real col_coeff = v/(real)ncols;

    for(int row=0; row<nrows; ++row)
        for(int col=0; col<ncols; ++col)
        {
            complex val = src[row*ncols+col];
            real r = _2PI * ((row*row_coeff) + (col*col_coeff));

            acc += (real)(val.x*cos(r) - val.y*sin(r));
        }

    acc /= (real)(nrows*ncols);
    int norm = (int)(acc) + 1;
    int4 out = (int4)(norm, norm, norm, 1.0);
    write_imagei(dest, (int2)(u, v), out);
}

kernel void product(global const complex2* restrict v1, global const complex2* restrict v2,
                    global complex2* restrict vprod, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    const int cols = ncols/2;
    if(c >= cols || r >= nrows)
        return;

    //z*w = (a*c - b*d) + (a*d + b*c)*i
    complex2 z = v1[r*cols+c];
    complex2 w = v2[r*cols+c];
    vprod[r*cols+c] = (complex2) (
                                  (z.s0*w.s0 - z.s1*w.s1), (z.s0*w.s1 + z.s1*w.s0),
                                  (z.s2*w.s2 - z.s3*w.s3), (z.s2*w.s3 + z.s3*w.s2)
                                 );
}
