#pragma OPENCL EXTENSION cl_khr_fp64 : enable
typedef double  real;
typedef double2 complex;
typedef double4 complex2;
typedef double8 complex4;

constant sampler_t sampler =
    CLK_NORMALIZED_COORDS_FALSE |
    CLK_ADDRESS_CLAMP_TO_EDGE |
    CLK_FILTER_NEAREST;

#define _2PI 6.283185307179586476925f

//FILTRI
kernel void identity(global real* restrict out, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    if (c >= ncols || r >= nrows)
        return;

    if(r == 1 && c == 1)
        out[r*ncols+c] = 1.0;
    else
        out[r*ncols+c] = 0.0;
}

kernel void Nbox3(global real* restrict out, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    if (c >= ncols || r >= nrows)
        return;

    if(r < 3 && c < 3)
        out[r*ncols+c] = 1.0/9;
    else
        out[r*ncols+c] = 0.0;
}

kernel void Nbox5(global real* restrict out, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    if (c >= ncols || r >= nrows)
        return;

    if(r < 5 && c < 5)
        out[r*ncols+c] = 1.0/25;
    else
        out[r*ncols+c] = 0.0;
}

kernel void sobelX(global real* restrict out, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    if (c >= ncols || r >= nrows)
        return;

    if(c == 0 && (r == 0 || r == 2))
        out[r*ncols+c] = 1.0;
    else if(c == 0 && r == 1)
        out[r*ncols+c] = 2.0;
    else if(c == 2 && (r == 0 || r == 2))
        out[r*ncols+c] = -1.0;
    else if(c == 2 && r == 1)
        out[r*ncols+c] = -2.0;
    else
        out[r*ncols+c] = 0.0;
}

kernel void sobelY(global real* restrict out, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    if (c >= ncols || r >= nrows)
        return;

    if(r == 0 && (c == 0 || c == 2))
        out[r*ncols+c] = 1.0;
    else if(r == 0 && c == 1)
        out[r*ncols+c] = 2.0;
    else if(r == 2 && (c == 0 || c == 2))
        out[r*ncols+c] = -1.0;
    else if(r == 2 && c == 1)
        out[r*ncols+c] = -2.0;
    else
        out[r*ncols+c] = 0.0;
}

kernel void fft_mat(global real* restrict src, global complex* restrict dest,
                    int nrows, int ncols)
{
#if 0
    const int v = get_global_id(0);
    const int u = get_global_id(1);
#else
    const int u = get_global_id(0);
    const int v = get_global_id(1);
#endif

    if(v >= ncols || u >= nrows)
        return;

    complex acc = (complex)(0, 0);
    const real row_coeff = u/(real)nrows;
    const real col_coeff = v/(real)ncols;

    for(int row=0; row<nrows; ++row)
        for(int col=0; col<ncols; ++col)
        {
            real val = src[row*ncols+col];
            real r = _2PI * ((row*row_coeff) + (col*col_coeff));
            acc += (complex)(val*cos(r), -sin(r)*val);
        }

    dest[u*ncols+v] = (complex)(acc.x, acc.y);
}

kernel void fft_img(image2d_t read_only src, global complex* restrict dest)
{
#if 0
    const int v = get_global_id(0);
    const int u = get_global_id(1);
#else
    const int u = get_global_id(0);
    const int v = get_global_id(1);
#endif
    const int ncols = get_image_width(src);
    const int nrows = get_image_height(src);

    if(v >= ncols || u >= nrows)
        return;

    complex acc = (complex)(0, 0);
    const real row_coeff = u/(real)nrows;
    const real col_coeff = v/(real)ncols;

    for(int row=0; row<nrows; ++row)
        for(int col=0; col<ncols; ++col)
        {
            float4 val = read_imagef(src, sampler, (int2)(row, col)); //f(x,y)
            real r = _2PI * ((row*row_coeff) + (col*col_coeff));
            acc += (complex)(val.x*cos(r), -sin(r)*val.x); //?
        }

    dest[u*ncols+v] = (complex)(acc.x, acc.y);
}

kernel void ifft(global complex* restrict src, image2d_t write_only dest)
{
#if 0
    const int v = get_global_id(0);
    const int u = get_global_id(1);
#else
    const int u = get_global_id(0);
    const int v = get_global_id(1);
#endif
    const int ncols = get_image_width(dest);
    const int nrows = get_image_height(dest);
    if(v >= ncols || u >= nrows)
        return;

    real acc = 0.0;
    const real row_coeff = u/(real)nrows;
    const real col_coeff = v/(real)ncols;

    for(int row=0; row<nrows; ++row)
        for(int col=0; col<ncols; ++col)
        {
            complex val = src[row*ncols+col];
            real r = _2PI * ((row*row_coeff) + (col*col_coeff));
            acc += (real)(val.x*cos(r) - val.y*sin(r));
        }
    acc /= (real)(nrows*ncols);

    real norm = clamp(acc, 0.0, 1.0);
    float4 out = (float4)(norm, norm, norm, 1);
    write_imagef(dest, (int2)(u, v), out);
}

kernel void product(global const complex2* restrict v1, global const complex2* restrict v2,
                    global complex2* restrict vprod, int nrows, int ncols)
{
#if 0
    int r = get_global_id(0);
    int c = get_global_id(1);
#else
    int c = get_global_id(0);
    int r = get_global_id(1);
#endif

    const int cols = ncols/2;
    if(c >= cols || r >= nrows)
        return;

    //z*w = (a*c - b*d) + (a*d + b*c)*i
    complex2 z = v1[r*cols+c];
    complex2 w = v2[r*cols+c];
    vprod[r*cols+c] = (complex2) (
                                  (z.s0*w.s0 - z.s1*w.s1), (z.s0*w.s1 + z.s1*w.s0),
                                  (z.s2*w.s2 - z.s3*w.s3), (z.s2*w.s3 + z.s3*w.s2)
                                 );
}
